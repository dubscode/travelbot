<turbo-frame id="messages-container">
{% for message in messages %}
    <div class="msg {% if message.role == 'user' %}msg--user{% else %}msg--bot{% endif %}">
        <div class="msg__avatar">
            {% if message.role == 'user' %}
                {{ user.name|first|upper }}
            {% else %}
                ü§ñ
            {% endif %}
        </div>
        <div class="msg__bubble">
            <div class="msg__text">{{ message.content|nl2br }}</div>
            {% if message.modelUsed %}
                <div class="msg__meta">
                    {% if 'haiku' in message.modelUsed|lower %}
                        ‚ö° Fast response
                    {% else %}
                        üß† Detailed response
                    {% endif %}
                </div>
            {% endif %}
        </div>
    </div>
{% endfor %}

<script>
// Immediately show typing indicator and start streaming AI response
setTimeout(() => {
    const typingIndicator = document.getElementById('typing-indicator');
    if (typingIndicator) {
        typingIndicator.style.display = 'flex';
    }
    
    // Scroll to show typing indicator
    const container = document.querySelector('.chat-messages');
    if (container) {
        container.scrollTop = container.scrollHeight;
    }

    // Create AI message bubble with immediate typing animation
    const currentFrame = document.querySelector('turbo-frame[id="messages-container"]');
    if (currentFrame) {
        const aiMessageHtml = `
            <div class="msg msg--bot" id="streaming-message">
                <div class="msg__avatar">ü§ñ</div>
                <div class="msg__bubble" id="streaming-content">
                    <span class="typing-dots-inline">
                        <span class="dot">‚óè</span>
                        <span class="dot">‚óè</span>
                        <span class="dot">‚óè</span>
                    </span>
                    <span id="cursor" style="display: none;">‚ñã</span>
                </div>
            </div>
        `;
        currentFrame.innerHTML += aiMessageHtml;
        
        // Add CSS for inline typing animation
        if (!document.getElementById('typing-animation-style')) {
            const style = document.createElement('style');
            style.id = 'typing-animation-style';
            style.textContent = `
                .typing-dots-inline {
                    display: inline-block;
                    color: #666;
                }
                .typing-dots-inline .dot {
                    animation: typing-pulse 1.4s infinite;
                    opacity: 0.4;
                }
                .typing-dots-inline .dot:nth-child(1) { animation-delay: 0s; }
                .typing-dots-inline .dot:nth-child(2) { animation-delay: 0.2s; }
                .typing-dots-inline .dot:nth-child(3) { animation-delay: 0.4s; }
                @keyframes typing-pulse {
                    0%, 60%, 100% { opacity: 0.4; }
                    30% { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Scroll to show new message
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }

    // Set up EventSource for streaming
    const eventSource = new EventSource('{{ path('app_chat_stream', {'messageId': userMessageId}) }}');
    
    eventSource.addEventListener('ready', function(event) {
        // Keep showing typing animation until first token
    });
    
    eventSource.addEventListener('start', function(event) {
        // Hide typing indicator - keep inline dots for now
        if (typingIndicator) {
            typingIndicator.style.display = 'none';
        }
    });
    
    eventSource.addEventListener('token', function(event) {
        const data = JSON.parse(event.data);
        const contentElement = document.getElementById('streaming-content');
        let cursor = document.getElementById('cursor');
        const typingDots = contentElement.querySelector('.typing-dots-inline');
        
        if (contentElement) {
            // On first token, switch from typing animation to streaming cursor
            if (typingDots) {
                typingDots.remove();
                if (cursor) cursor.style.display = 'inline';
            }
            
            // Remove cursor temporarily to add token, but keep reference
            let cursorWasVisible = false;
            if (cursor && cursor.parentNode) {
                cursorWasVisible = true;
                cursor.remove();
            }
            
            // Create text node and append to existing content
            const tokenSpan = document.createElement('span');
            tokenSpan.textContent = data.text;
            contentElement.appendChild(tokenSpan);
            
            // Re-create and add cursor back if it was visible
            if (cursorWasVisible) {
                cursor = document.createElement('span');
                cursor.id = 'cursor';
                cursor.textContent = '‚ñã';
                cursor.style.display = 'inline';
                contentElement.appendChild(cursor);
            }
            
            // Scroll to bottom
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        }
    });
    
    eventSource.addEventListener('complete', function(event) {
        // Remove cursor
        const cursor = document.getElementById('cursor');
        if (cursor) {
            cursor.remove();
        }
        
        // Add model indicator
        const contentElement = document.getElementById('streaming-content');
        if (contentElement) {
            const modelInfo = document.createElement('div');
            modelInfo.style.cssText = 'font-size: 12px; opacity: 0.7; margin-top: 8px;';
            modelInfo.innerHTML = 'üß† Detailed response';
            contentElement.appendChild(modelInfo);
        }
        
        // Close connection and re-enable form
        eventSource.close();
        
        const btn = document.getElementById('send-btn');
        if (btn) {
            btn.disabled = false;
            btn.textContent = 'Send üì®';
        }
        
        // Final scroll
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    });
    
    eventSource.addEventListener('error', function(event) {
        
        // Remove streaming elements
        const streamingMessage = document.getElementById('streaming-message');
        if (streamingMessage) {
            streamingMessage.remove();
        }
        
        // Hide typing indicator
        if (typingIndicator) {
            typingIndicator.style.display = 'none';
        }
        
        // Show error message
        if (currentFrame) {
            const errorHtml = `
                <div class="msg msg--bot">
                    <div class="msg__avatar">ü§ñ</div>
                    <div class="msg__bubble">
                        <div class="msg__text">Sorry, I encountered an error processing your request. Please try again.</div>
                    </div>
                </div>
            `;
            currentFrame.innerHTML += errorHtml;
        }
        
        // Close connection and re-enable form
        eventSource.close();
        
        const btn = document.getElementById('send-btn');
        if (btn) {
            btn.disabled = false;
            btn.textContent = 'Send üì®';
        }
    });
    
    eventSource.onerror = function(event) {
        eventSource.close();
        
        // Fallback to non-streaming approach
        fetch('{{ path('app_chat_ai_response', {'messageId': userMessageId}) }}', {
            headers: {
                'Accept': 'text/html',
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.text())
        .then(html => {
            // Replace the entire frame with fallback response
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const newFrame = doc.querySelector('turbo-frame[id="messages-container"]');
            if (newFrame && currentFrame) {
                currentFrame.innerHTML = newFrame.innerHTML;
            }
        })
        .catch(error => {
            console.error('Fallback also failed:', error);
            
            // Show error message
            if (currentFrame) {
                const errorHtml = `
                    <div class="msg msg--bot">
                        <div class="msg__avatar">ü§ñ</div>
                        <div class="msg__bubble">
                            <div class="msg__text">Sorry, I encountered an error processing your request. Please try again.</div>
                        </div>
                    </div>
                `;
                currentFrame.innerHTML += errorHtml;
            }
        })
        .finally(() => {
            // Hide typing indicator and re-enable form
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
            
            const btn = document.getElementById('send-btn');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Send üì®';
            }
            
            if (container) {
                container.scrollTop = container.scrollHeight;
            }
        });
    };
    
}, 100); // Small delay to ensure DOM is ready
</script>
</turbo-frame>