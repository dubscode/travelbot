name: üöÄ Production Deployment

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean
      rollback_version:
        description: 'Rollback to specific image tag (leave empty for normal deployment)'
        required: false
        type: string

concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY: travelbot
  ECS_CLUSTER: travelbot-cluster
  ECS_SERVICE: travelbot-service
  CONTAINER_NAME: travelbot
  
permissions:
  id-token: write
  contents: read
  deployments: write

jobs:
  # ==================================================================================
  # Pre-deployment checks
  # ==================================================================================
  pre-deployment:
    name: üîç Pre-deployment Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}
      cluster_name: ${{ steps.aws-info.outputs.cluster_name }}
      service_name: ${{ steps.aws-info.outputs.service_name }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Check if deployment needed
        id: check
        run: |
          if [[ "${{ github.event.inputs.rollback_version }}" != "" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=${{ github.event.inputs.rollback_version }}" >> $GITHUB_OUTPUT
            echo "üîÑ Rollback requested to version: ${{ github.event.inputs.rollback_version }}"
          elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "image_tag=${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT
            echo "üöÄ Force deployment requested"
          else
            # Check if there are changes to application code
            if git diff --name-only HEAD HEAD~1 | grep -E '\.(php|js|ts|css|scss|twig|yaml|yml|json|lock)$|Dockerfile|composer\.' | head -1; then
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "image_tag=${GITHUB_SHA:0:8}" >> $GITHUB_OUTPUT
              echo "üì¶ Application changes detected, deployment needed"
            else
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "‚è≠Ô∏è No application changes detected, skipping deployment"
            fi
          fi

      - name: üèóÔ∏è Configure AWS credentials
        if: steps.check.outputs.should_deploy == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ASSUME_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-PreDeployment

      - name: üìã Get AWS resource information
        if: steps.check.outputs.should_deploy == 'true'
        id: aws-info
        run: |
          # Get actual cluster and service names from AWS
          CLUSTER_NAME=$(aws ecs list-clusters --query 'clusterArns[?contains(@, `travelbot`)]' --output text | head -1 | cut -d'/' -f2)
          SERVICE_NAME=$(aws ecs list-services --cluster $CLUSTER_NAME --query 'serviceArns[?contains(@, `travelbot`)]' --output text | head -1 | cut -d'/' -f3)
          
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          
          echo "üèóÔ∏è Found ECS Cluster: $CLUSTER_NAME"
          echo "üèóÔ∏è Found ECS Service: $SERVICE_NAME"

  # ==================================================================================
  # Build and Push Docker Image
  # ==================================================================================
  build-and-push:
    name: üê≥ Build & Push Image
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should_deploy == 'true' && github.event.inputs.rollback_version == ''
    timeout-minutes: 30

    outputs:
      image_uri: ${{ steps.output.outputs.image_uri }}
      image_digest: ${{ steps.output.outputs.image_digest }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üèóÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ASSUME_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Build

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîë Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          target: production
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.pre-deployment.outputs.image_tag }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}

      - name: üìã Output image information
        id: output
        run: |
          echo "image_uri=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.pre-deployment.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "image_digest=${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT

  # ==================================================================================
  # Blue/Green ECS Deployment
  # ==================================================================================
  deploy:
    name: üéØ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-push]
    if: needs.pre-deployment.outputs.should_deploy == 'true' && (always() && (needs.build-and-push.result == 'success' || github.event.inputs.rollback_version != ''))
    timeout-minutes: 30
    

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üèóÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ASSUME_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy

      - name: üîë Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üìã Prepare deployment variables
        id: vars
        run: |
          if [[ "${{ github.event.inputs.rollback_version }}" != "" ]]; then
            IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.event.inputs.rollback_version }}"
            echo "deployment_type=rollback" >> $GITHUB_OUTPUT
          else
            IMAGE_URI="${{ needs.build-and-push.outputs.image_uri }}"
            echo "deployment_type=deploy" >> $GITHUB_OUTPUT
          fi
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "üéØ Deploying image: $IMAGE_URI"

      - name: üìä Get current task definition
        id: current-task
        run: |
          CURRENT_TASK_DEF=$(aws ecs describe-services \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }} \
            --query 'services[0].taskDefinition' --output text)
          echo "current_task_definition=$CURRENT_TASK_DEF" >> $GITHUB_OUTPUT
          echo "üìã Current task definition: $CURRENT_TASK_DEF"

      - name: üîÑ Create new task definition
        id: new-task
        run: |
          # Download current task definition
          aws ecs describe-task-definition \
            --task-definition ${{ steps.current-task.outputs.current_task_definition }} \
            --query 'taskDefinition' > task-def.json

          # Update image URI in task definition
          NEW_TASK_DEF=$(cat task-def.json | jq --arg IMAGE_URI "${{ steps.vars.outputs.image_uri }}" '
            .containerDefinitions[0].image = $IMAGE_URI |
            del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)
          ')

          # Register new task definition
          echo "$NEW_TASK_DEF" > new-task-def.json
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://new-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' --output text)
          
          echo "new_task_definition=$NEW_TASK_ARN" >> $GITHUB_OUTPUT
          echo "üÜï New task definition: $NEW_TASK_ARN"

      - name: üéØ Update ECS service (Blue/Green deployment)
        id: deploy
        run: |
          echo "üöÄ Starting deployment..."
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --service ${{ needs.pre-deployment.outputs.service_name }} \
            --task-definition ${{ steps.new-task.outputs.new_task_definition }} \
            --force-new-deployment
          
          echo "‚úÖ Service update initiated"

      - name: ‚è±Ô∏è Wait for deployment to complete
        id: wait
        run: |
          echo "‚è±Ô∏è Waiting for deployment to stabilize..."
          
          aws ecs wait services-stable \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }}
          
          echo "‚úÖ Deployment completed successfully"

      - name: üîç Health check
        id: health-check
        run: |
          echo "ü©∫ Performing health checks..."
          
          # Wait a bit for the service to fully start
          sleep 30
          
          # Get the load balancer URL
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names travelbot-alb \
            --query 'LoadBalancers[0].DNSName' --output text)
          
          # Health check endpoint
          HEALTH_URL="https://travelbot.tech/health"
          
          echo "üîç Checking health endpoint: $HEALTH_URL"
          
          # Retry health check up to 10 times
          for i in {1..10}; do
            if curl -f -s "$HEALTH_URL" > /dev/null; then
              echo "‚úÖ Health check passed (attempt $i)"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ö†Ô∏è Health check failed (attempt $i/10)"
              if [ $i -eq 10 ]; then
                echo "‚ùå Health check failed after 10 attempts"
                echo "health_status=unhealthy" >> $GITHUB_OUTPUT
                exit 1
              fi
              sleep 30
            fi
          done

      - name: üìä Post-deployment validation
        run: |
          echo "üìä Running post-deployment validation..."
          
          # Check ECS service status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }} \
            --query 'services[0].status' --output text)
          
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }} \
            --query 'services[0].runningCount' --output text)
          
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }} \
            --query 'services[0].desiredCount' --output text)
          
          echo "üìã Service Status: $SERVICE_STATUS"
          echo "üìã Running Tasks: $RUNNING_COUNT/$DESIRED_COUNT"
          
          if [[ "$SERVICE_STATUS" == "ACTIVE" && "$RUNNING_COUNT" == "$DESIRED_COUNT" ]]; then
            echo "‚úÖ Post-deployment validation passed"
          else
            echo "‚ùå Post-deployment validation failed"
            exit 1
          fi

  # ==================================================================================
  # Rollback (if deployment fails)
  # ==================================================================================
  rollback:
    name: üîÑ Automatic Rollback
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy]
    if: needs.deploy.result == 'failure' && github.event.inputs.rollback_version == ''
    timeout-minutes: 15

    steps:
      - name: üèóÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ASSUME_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Rollback

      - name: üîÑ Rollback to previous version
        run: |
          echo "üîÑ Rolling back to previous task definition..."
          
          # Get the current (failed) task definition
          CURRENT_TASK=$(aws ecs describe-services \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }} \
            --query 'services[0].taskDefinition' --output text)
          
          # Get previous task definition (assuming it was the previous revision)
          TASK_FAMILY=$(echo $CURRENT_TASK | cut -d':' -f1)
          CURRENT_REVISION=$(echo $CURRENT_TASK | cut -d':' -f2)
          PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
          PREVIOUS_TASK="$TASK_FAMILY:$PREVIOUS_REVISION"
          
          echo "üîÑ Rolling back from $CURRENT_TASK to $PREVIOUS_TASK"
          
          # Update service with previous task definition
          aws ecs update-service \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --service ${{ needs.pre-deployment.outputs.service_name }} \
            --task-definition $PREVIOUS_TASK
          
          # Wait for rollback to complete
          aws ecs wait services-stable \
            --cluster ${{ needs.pre-deployment.outputs.cluster_name }} \
            --services ${{ needs.pre-deployment.outputs.service_name }}
          
          echo "‚úÖ Rollback completed"

